"use strict";

var type = require("type-of"),
    assert = require("./assert"),
    dataType = require("./data-type"),
    listUtil = require("./list-util"),
    category = require("./category");

var bind = function bind(v, k) {
  return k(v);
};

var first = function first(list) {
  return list[0];
};

var tail = function tail(list) {
  return list.slice(1);
};

var getLast = function getLast(list) {
  return list[list.length - 1];
};

var initial = function initial(list) {
  return list.slice(0, list.length - 1);
};

var transformOperation = function transformOperation(ast, environment) {
  assert.array(ast, "transform");
  var head = first(ast),
      ctor = dictionary[head];

  if (type(head) === "string" && type(ctor) === "function") {
    var args = ast.slice(1);
    return ctor(args, environment);
  } else {
    ctor = dictionary["__call_expression__"];
    return ctor(ast, environment);
  }

  return undefined;
};

var readToken = function readToken(text) {
  if (text === "super") {
    return {
      type: "Super"
    };
  }

  if (text === "this" || text === "@") {
    return {
      type: "ThisExpression"
    };
  }

  text = text.replace(/^@/, "this.");

  if (["true", "false"]["indexOf"](text) >= 0) {
    return {
      type: "BooleanLiteral",
      value: text === "true" ? true : false
    };
  }

  if (text === "null") {
    return {
      type: "NullLiteral"
    };
  }

  if (text.match(/^\w/) && !text.match(/^\d/)) {
    if (text.match(/\./)) {
      var names = text.split(".");
      return buildMembers(names);
    } else {
      return {
        type: "Identifier",
        name: text
      };
    }
  } else {
    var value = dataType.decode(text);

    switch (true) {
      case type(value) === "regexp":
        return {
          type: "RegExpLiteral",
          extra: {
            raw: String(value)
          },
          pattern: text.substr(1),
          flags: ""
        };
        break;

      case type(value) === "number":
        return {
          type: "NumericLiteral",
          extra: {
            rawValue: value,
            raw: String(value)
          },
          value: value
        };
        break;

      case type(value) === "string":
        return {
          type: "StringLiteral",
          extra: {
            rawValue: value,
            raw: JSON.stringify(value)
          },
          value: value
        };
        break;

      default:
        return {
          type: "Literal",
          value: value,
          raw: String(value)
        };
        break;
    }
  }

  return undefined;
};

var decideSolution = function decideSolution(x, environment) {
  assert.oneOf(environment, ["statement", "expression"], "environment");

  if (type(x) === "array") {
    var result = transformOperation(x, "expression");
  }

  if (type(x) === "string") {
    var result = readToken(x);
  }

  if (!(result != null)) {
    var inStr = JSON.stringify(x);
    throw new Error("Unknown chunk: " + inStr);
  }

  if (environment === "statement") {
    if (type(x) === "string") {
      return {
        type: "ExpressionStatement",
        expression: result
      };
    }

    if (type(x) === "array") {
      var head = x[0];

      if (!(type(head) === "string") || type(head) === "string" && !(category.statement["indexOf"](head) >= 0)) {
        var names = ["ObjectExpression", "FunctionExpression"];

        if (names["indexOf"](result.type) >= 0) {
          result.extra = {
            parenthesized: true
          };
        }

        return {
          type: "ExpressionStatement",
          expression: result
        };
      }
    }
  }

  return result;
};

var makeIdentifier = function makeIdentifier(name) {
  return {
    type: "Identifier",
    name: name
  };
};

var buildMembers = function buildMembers(names) {
  if (names.length < 1) {
    throw new Error("Cannot build MemberExpression with nothing");
  }

  if (names.length === 1) {
    return decideSolution(first(names), "expression");
  }

  return {
    type: "MemberExpression",
    computed: false,
    object: buildMembers(initial(names)),
    property: makeIdentifier(getLast(names))
  };
};

var buildChain = function buildChain(names) {
  if (names.length === 1) {
    return decideSolution(first(names), "expression");
  }

  var listInitial = initial(names),
      last = getLast(names);
  assert.array(last, "last of buildChain");
  var method = first(last),
      args = tail(last);
  assert.string(method, "method of buildChain");
  return {
    type: "CallExpression",
    callee: {
      type: "MemberExpression",
      computed: false,
      object: buildChain(listInitial),
      property: makeIdentifier(method)
    },
    arguments: args.map(function (item) {
      return decideSolution(item, "expression");
    })
  };
};

var dictionary = {
  __assgin__: function __assgin__(args, environment) {
    var name = args[0],
        value = args[1];
    return {
      type: "AssignmentExpression",
      operator: "=",
      left: decideSolution(name, "expression"),
      right: decideSolution(value, "expression")
    };
  },
  "var": function _var(args, environment) {
    assert.array(args, "variable declarations");
    var first = args[0],
        init = args[1];

    if (type(first) === "string") {
      return {
        type: "VariableDeclaration",
        declarations: [{
          type: "VariableDeclarator",
          id: makeIdentifier(first),
          init: init ? bind(decideSolution(init, "expression"), function (result) {
            if (result.type === "FunctionExpression") {
              result.id = makeIdentifier(first);
            }

            return result;
          }) : null
        }],
        kind: "var"
      };
    }

    return {
      type: "VariableDeclaration",
      declarations: args.map(function (pair) {
        assert.array(pair, "declarations in var");
        var name = pair[0];
        var init = pair[1];
        return {
          type: "VariableDeclarator",
          id: decideSolution(name, "expression"),
          init: init ? decideSolution(init, "expression") : null
        };
      }),
      kind: "var"
    };
  },
  array: function array(args, environment) {
    assert.array(args, "array args");
    return {
      type: "ArrayExpression",
      elements: args.map(function (item) {
        return decideSolution(item, "expression");
      })
    };
  },
  "array~": function array(args, environment) {
    assert.array(args, "ArrayPattern");
    return {
      type: "ArrayPattern",
      elements: args.map(function (item) {
        if (type(item) === "string") {
          return decideSolution(item, "expression");
        }

        undefined
        assert.array(item, "item in ArrayPattern");
        assert.result(item.length === 1, "an only item in array");
        assert.string(item[0], "simple string in ArrayPattern");
        return {
          type: "RestElement",
          argument: makeIdentifier(item[0])
        };
      })
    };
  },
  "+": function _(args, environment) {
    assert.array(args, "args for +");
    assert.result(args.length > 0, "args for + should no be empty");

    if (args.length === 1) {
      return decideSolution(args[0], "expression");
    }

    var self = dictionary["+"];
    return {
      type: "BinaryExpression",
      left: self(initial(args), "expression"),
      operator: "+",
      right: decideSolution(getLast(args), "expression")
    };
  },
  "*": function _(args, environment) {
    assert.array(args, "args for *");
    assert.result(args.length > 0, "args for * should not be empty");

    if (args.length === 1) {
      return decideSolution(args[0], "expression");
    }

    var self = dictionary["*"];
    return {
      type: "BinaryExpression",
      operator: "*",
      left: self(initial(args), "expression"),
      right: decideSolution(getLast(args), "expression")
    };
  },
  "-": function _(args, environment) {
    assert.array(args, "args for -");
    assert.result(args.length > 0, "args for - should no be empty");

    if (args.length === 1) {
      return decideSolution(args[0], "expression");
    }

    var self = dictionary["-"];
    return {
      type: "BinaryExpression",
      operator: "-",
      left: self(initial(args), "expression"),
      right: decideSolution(getLast(args), "expression")
    };
  },
  "/": function _(args, environment) {
    assert.array(args, "args for /");
    assert.result(args.length > 0, "args for / should no be empty");

    if (args.length === 1) {
      return decideSolution(args[0], "expression");
    }

    var self = dictionary["/"];
    return {
      type: "BinaryExpression",
      operator: "/",
      left: self(initial(args), "expression"),
      right: decideSolution(getLast(args), "expression")
    };
  },
  "%": function _(args, environment) {
    assert.array(args, "args for %");
    assert.result(args.length > 0, "args for % should no be empty");

    if (args.length === 1) {
      return decideSolution(args[0], "expression");
    }

    var self = dictionary["%"];
    return {
      type: "BinaryExpression",
      operator: "%",
      left: self(initial(args), "expression"),
      right: decideSolution(getLast(args), "expression")
    };
  },
  "\\": function _(args, environment) {
    assert.array(args, "function");
    var params = args[0],
        body = args.slice(1);
    assert.array(params, "params");
    return {
      body: {
        type: "BlockStatement",
        body: body.map(function (line, index) {
          if (index === body.length - 1 && line[0] !== "return") {
            line = ["return", line];
          }

          return decideSolution(line, "statement");
        }),
        directives: []
      },
      params: params.map(function (item) {
        if (type(item) === "string") {
          return makeIdentifier(item);
        } else {
          var param = item[0];
          assert.string(param, "rest of params");
          return {
            type: "RestElement",
            argument: makeIdentifier(param)
          };
        }

        return undefined;
      }),
      generator: false,
      expression: false,
      type: "FunctionExpression",
      id: null
    };
  },
  "return": function _return(args, environment) {
    assert.array(args, "return");
    var argument = args[0];
    return {
      type: "ReturnStatement",
      argument: argument != null ? decideSolution(argument, "expression") : null
    };
  },
  "\\\\": function _(args, environment) {
    assert.array(args, "function");
    var params = args[0],
        body = args.slice(1);
    assert.array(params, "params");
    return {
      type: "ArrowFunctionExpression",
      id: null,
      params: params.map(function (item) {
        if (type(item) === "string") {
          return makeIdentifier(item);
        } else {
          var param = item[0];
          assert.string(param, "rest of params");
          return {
            type: "RestElement",
            argument: makeIdentifier(param)
          };
        }

        return undefined;
      }),
      generator: false,
      expression: body.length === 1,
      body: body.length === 1 ? decideSolution(body[0], "expression") : {
        type: "BlockStatement",
        body: body.map(function (line, index) {
          if (index === body.length - 1 && line[0] !== "return") {
            line = ["return", line];
          }

          return decideSolution(line, "statement");
        }),
        directives: []
      }
    };
  },
  object: function object(args, environment) {
    assert.array(args, "args for object");

    if (type(args[0]) === "string") {
      args = listUtil.foldPair(args);
    }

    return {
      type: "ObjectExpression",
      properties: args.map(function (pair) {
        assert.array(pair, "object property");
        var name = pair[0],
            init = pair[1];
        assert.string(name, "object property key");
        return {
          type: "ObjectProperty",
          key: name.match(/^:\w[\w\d_$]*$/) != null ? {
            type: "Identifier",
            name: name.substr(1)
          } : {
            type: "StringLiteral",
            extra: {
              rawValue: name.substr(1),
              raw: JSON.stringify(name.substr(1))
            },
            value: name.substr(1)
          },
          computed: false,
          value: decideSolution(init, "expression"),
          method: false,
          shorthand: false
        };
      })
    };
  },
  "object~": function object(args, environment) {
    assert.array(args, "args for ObjectPattern");
    return {
      type: "ObjectPattern",
      properties: args.map(function (property) {
        assert.string(property, "property in ObjectPattern");
        var pattern = makeIdentifier(property);
        return {
          method: false,
          shorthand: true,
          computed: false,
          extra: {
            shorthand: true
          },
          value: pattern,
          type: "ObjectProperty",
          key: pattern
        };
      })
    };
  },
  ".": function _(args, environment) {
    assert.array(args, "args for member");
    var object = args[0],
        property = args[1];
    return type(property) === "string" && property[0] === ":" && property.slice(1).match(/^\w[\w\d_]*$/) != null ? {
      type: "MemberExpression",
      computed: false,
      object: decideSolution(object, "expression"),
      property: {
        type: "Identifier",
        name: property.substr(1)
      }
    } : {
      type: "MemberExpression",
      computed: true,
      object: decideSolution(object, "expression"),
      property: decideSolution(property, "expression")
    };
  },
  and: function and(args, environment) {
    assert.array(args, "args for and");
    assert.result(args.length > 0, "args for and should not be empty");

    if (args.length === 1) {
      return decideSolution(args[0], "expression");
    }

    var self = dictionary["and"];
    return {
      type: "LogicalExpression",
      operator: "&&",
      left: self(initial(args), "expression"),
      right: decideSolution(getLast(args), "expression")
    };
  },
  or: function or(args, environment) {
    assert.array(args, "args for or");
    assert.result(args.length > 0, "args for or should not be empty");

    if (args.length === 1) {
      return decideSolution(args[0], "expression");
    }

    var self = dictionary["or"];
    return {
      type: "LogicalExpression",
      operator: "||",
      left: self(initial(args), "expression"),
      right: decideSolution(getLast(args), "expression")
    };
  },
  not: function not(args, environment) {
    assert.array(args, "not");
    return {
      type: "UnaryExpression",
      operator: "!",
      prefix: true,
      extra: {
        parenthesizedArgument: false
      },
      argument: decideSolution(first(args), "expression")
    };
  },
  "if": function _if(args, environment) {
    assert.array(args, "if");
    var test = args[0],
        consequent = args[1],
        alternate = args[2],
        consequentBody = consequent.slice(1);
    return {
      type: "IfStatement",
      test: decideSolution(test, "expression"),
      consequent: {
        type: "BlockStatement",
        body: consequentBody.map(function (item) {
          return decideSolution(item, "statement");
        }),
        directives: []
      },
      alternate: alternate != null ? {
        type: "BlockStatement",
        body: alternate.slice(1).map(function (item) {
          return decideSolution(item, "statement");
        }),
        directives: []
      } : null
    };
  },
  "do": function _do(args, environment) {
    assert.array(args, "do");
    return {
      type: "BlockStatement",
      body: args.map(function (line) {
        return decideSolution(line, "statement");
      }),
      directives: []
    };
  },
  cond: function cond(args, environment) {
    assert.array(args, "cond");
    var test = args[0],
        consequent = args[1],
        alternate = args[2];
    assert.defined(test, "test of cond");
    assert.defined(consequent, "test of consequent");

    if (alternate != null) {
      var alternateAst = decideSolution(alternate, "expression");
    } else {
      var alternateAst = {
        type: "Identifier",
        name: "undefined"
      };
    }

    return {
      type: "ConditionalExpression",
      test: decideSolution(test, "expression"),
      consequent: decideSolution(consequent, "expression"),
      alternate: alternateAst
    };
  },
  "--": function _(args, environment) {
    return {
      type: "Identifier",
      name: "undefined"
    };
  },
  __call_expression__: function __call_expression__(args, environment) {
    assert.array(args, "__call_expression__");
    var callee = args[0],
        args = args.slice(1);
    return {
      type: "CallExpression",
      callee: decideSolution(callee, "expression"),
      arguments: args.map(function (item) {
        return decideSolution(item, "expression");
      })
    };
  },
  is: function is(args, environment) {
    assert.array(args, "is");
    return {
      type: "BinaryExpression",
      operator: "===",
      left: decideSolution(args[0], "expression"),
      right: decideSolution(args[1], "expression")
    };
  },
  isnt: function isnt(args, environment) {
    assert.array(args, "isnt");
    return {
      type: "BinaryExpression",
      operator: "!==",
      left: decideSolution(args[0], "expression"),
      right: decideSolution(args[1], "expression")
    };
  },
  ">": function _(args, environment) {
    assert.array(args, ">");
    return {
      type: "BinaryExpression",
      operator: ">",
      left: decideSolution(args[0], "expression"),
      right: decideSolution(args[1], "expression")
    };
  },
  ">=": function _(args, environment) {
    assert.array(args, ">=");
    return {
      type: "BinaryExpression",
      operator: ">=",
      left: decideSolution(args[0], "expression"),
      right: decideSolution(args[1], "expression")
    };
  },
  "<": function _(args, environment) {
    assert.array(args, "<");
    return {
      type: "BinaryExpression",
      operator: "<",
      left: decideSolution(args[0], "expression"),
      right: decideSolution(args[1], "expression")
    };
  },
  "<=": function _(args, environment) {
    assert.array(args, "<=");
    return {
      type: "BinaryExpression",
      operator: "<=",
      left: decideSolution(args[0], "expression"),
      right: decideSolution(args[1], "expression")
    };
  },
  "debugger": function _debugger(args, environment) {
    return {
      type: "DebuggerStatement"
    };
  },
  "continue": function _continue(args, environment) {
    return {
      type: "ContinueStatement",
      label: null
    };
  },
  "break": function _break(args, environment) {
    return {
      type: "BreakStatement",
      label: null
    };
  },
  "new": function _new(args, environment) {
    assert.array(args, "new");
    var callee = args[0],
        args = args.slice(1);
    return {
      type: "NewExpression",
      callee: decideSolution(callee, "expression"),
      arguments: args.map(function (item) {
        return decideSolution(item, "expression");
      })
    };
  },
  "throw": function _throw(args, environment) {
    assert.array(args, "throw");
    var argument = args[0];
    assert.defined(argument, "argument of throw");
    return {
      type: "ThrowStatement",
      argument: decideSolution(argument, "expression")
    };
  },
  "?": function _(args, environment) {
    assert.array(args, "?");
    var value = args[0];
    return {
      type: "BinaryExpression",
      operator: "!=",
      left: decideSolution(value, "expression"),
      right: {
        type: "NullLiteral"
      }
    };
  },
  "in": function _in(args, environment) {
    assert.array(args, "in");
    var collection = args[0],
        value = args[1];
    return {
      type: "BinaryExpression",
      left: {
        type: "CallExpression",
        callee: {
          type: "MemberExpression",
          object: decideSolution(collection, "expression"),
          property: {
            type: "Identifier",
            name: "indexOf"
          },
          computed: false
        },
        arguments: [decideSolution(value, "expression")]
      },
      operator: ">=",
      right: {
        type: "NumericLiteral",
        extra: {
          rawValue: 0,
          raw: "0"
        },
        value: 0
      }
    };
  },
  "try": function _try(args, environment) {
    assert.array(args, "try");
    var block = args[0],
        handler = args[1];
    assert.array(args, "handler of try");
    var param = handler[0],
        body = handler.slice(1);
    assert.string(param, "param of try");
    assert.array(body, "body of try");
    return {
      type: "TryStatement",
      block: decideSolution(block, "expression"),
      finalizer: null,
      guardedHandlers: [],
      handler: {
        type: "CatchClause",
        param: makeIdentifier(param),
        body: {
          type: "BlockStatement",
          body: body.map(function (item) {
            return decideSolution(item, "statement");
          }),
          directives: []
        }
      }
    };
  },
  "switch": function _switch(args, environment) {
    assert.array(args, "switch");
    var discriminant = args[0],
        cases = args.slice(1);
    assert.array(cases, "cases of switch");
    return {
      type: "SwitchStatement",
      discriminant: decideSolution(discriminant, "expression"),
      cases: cases.map(function (item) {
        assert.array(item, "case of switch");
        var test = item[0],
            consequent = item.slice(1),
            consequentCode = listUtil.append(consequent, ["break"]);
        return {
          type: "SwitchCase",
          consequent: consequentCode.map(function (item) {
            return decideSolution(item, "statement");
          }),
          test: test === "else" ? null : decideSolution(test, "expression")
        };
      })
    };
  },
  "case": function _case(args, environment) {
    assert.array(args, "case");
    var discriminant = args[0],
        cases = args.slice(1);
    assert.array(cases, "cases of case");
    return {
      type: "CallExpression",
      arguments: [],
      callee: {
        type: "ArrowFunctionExpression",
        id: null,
        params: [],
        generator: false,
        expression: false,
        extra: {
          parenthesized: true
        },
        body: {
          type: "BlockStatement",
          body: [{
            type: "SwitchStatement",
            discriminant: decideSolution(discriminant, "expression"),
            cases: cases.map(function (item) {
              assert.array(item, "case of switch");
              var test = item[0],
                  consequent = item.slice(1);
              return {
                type: "SwitchCase",
                test: test === "else" ? null : decideSolution(test, "expression"),
                consequent: consequent.map(function (item, index) {
                  return index === consequent.length - 1 ? {
                    type: "ReturnStatement",
                    argument: decideSolution(item, "expression")
                  } : decideSolution(item, "expression");
                })
              };
            })
          }],
          directives: []
        }
      }
    };
  },
  "...": function _(args, environment) {
    if (args.length === 1) {
      assert.array(args, "spread");
      var argument = args[0];
      assert.string("argument", "argument of spread");
      return {
        type: "SpreadElement",
        argument: makeIdentifier(argument)
      };
    } else {
      assert.array(args, "chain");
      return buildChain(args);
    }

    return undefined;
  },
  "class": function _class(args, environment) {
    assert.array(args, "class");
    var className = first(args),
        superClass = null,
        classMethods = tail(args);

    if (type(className) === "array") {
      assert.result(className.length === 2, "class declarations");
      superClass = getLast(className);
      className = first(className);
    }

    return {
      type: "ClassDeclaration",
      id: makeIdentifier(className),
      superClass: superClass != null ? makeIdentifier(superClass) : null,
      body: {
        type: "ClassBody",
        body: classMethods.map(function (pair) {
          assert.result(pair.length === 2, "MethodDefinition");
          var keyName = first(pair),
              prefix = [],
              definition = getLast(pair),
              kind = "method",
              isStatic = false;

          if (type(keyName) === "array") {
            prefix = initial(keyName);
            keyName = getLast(keyName);
          }

          if (prefix["indexOf"]("get") >= 0) {
            kind = "get";
          }

          if (prefix["indexOf"]("set") >= 0) {
            kind = "set";
          }

          if (prefix["indexOf"]("static") >= 0) {
            isStatic = true;
          }

          if (keyName === "constructor") {
            kind = "constructor";
          }

          assert.string(keyName, "keyName in class");
          assert.array(definition, "definition in class");
          return {
            type: "MethodDefinition",
            key: makeIdentifier(keyName),
            value: decideSolution(definition, "expression"),
            kind: kind,
            "static": isStatic,
            computed: false
          };
        })
      }
    };
  }
};
dictionary["[]"] = dictionary.array;
dictionary["[]~"] = dictionary["array~"];
dictionary["{}"] = dictionary.object;
dictionary["{}~"] = dictionary["object~"];
dictionary["="] = dictionary["__assgin__"];

exports.transform = function (tree) {
  var environment = "statement",
      list = tree.map(function (line) {
    return decideSolution(line, environment);
  });
  return {
    type: "File",
    program: {
      type: "Program",
      sourceType: "script",
      body: list,
      directives: []
    }
  };
};