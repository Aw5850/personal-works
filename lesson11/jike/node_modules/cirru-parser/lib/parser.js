var _escape_else, _escape_eof, _escape_n, _escape_newline, _escape_t, _indent_close, _indent_else, _indent_eof, _indent_newilne, _indent_space, _space_close, _space_else, _space_eof, _space_newline, _space_open, _space_quote, _space_space, _string_backslash, _string_else, _string_eof, _string_newline, _string_quote, _token_close, _token_else, _token_eof, _token_newline, _token_open, _token_quote, _token_space, parse, tree;

tree = require('./tree');

exports.parse = function(code, filename) {
  var buffer, ref, res, state, xs;
  buffer = null;
  state = {
    name: 'indent',
    x: 1,
    y: 1,
    level: 1,
    indent: 0,
    indented: 0,
    nest: 0,
    path: filename
  };
  xs = [];
  while (code.length > 0) {
    ref = parse(xs, buffer, state, code), xs = ref[0], buffer = ref[1], state = ref[2], code = ref[3];
  }
  res = parse(xs, buffer, state, code);
  res = res.map(tree.resolveDollar);
  res = res.map(tree.resolveComma);
  return res;
};

exports.pare = function(code, filename) {
  var res, shorten;
  res = exports.parse(code, filename);
  shorten = function(xs) {
    if (Array.isArray(xs)) {
      return xs.map(shorten);
    } else {
      return xs.text;
    }
  };
  return shorten(res);
};

_escape_eof = function(xs, buffer, state, code) {
  throw new Error("EOF in escape state");
};

_string_eof = function(xs, buffer, state, code) {
  throw new Error("EOF in string state");
};

_space_eof = function(xs, buffer, state, code) {
  return xs;
};

_token_eof = function(xs, buffer, state, code) {
  buffer.ex = state.x;
  buffer.ey = state.y;
  xs = tree.appendItem(xs, state.level, buffer);
  buffer = null;
  return xs;
};

_indent_eof = function(xs, buffer, state, code) {
  return xs;
};

_escape_newline = function(xs, buffer, state, code) {
  throw new Error('newline while escape');
};

_escape_n = function(xs, buffer, state, code) {
  state.x += 1;
  buffer.text += '\n';
  state.name = 'string';
  return [xs, buffer, state, code.slice(1)];
};

_escape_t = function(xs, buffer, state, code) {
  state.x += 1;
  buffer.text += '\t';
  state.name = 'string';
  return [xs, buffer, state, code.slice(1)];
};

_escape_else = function(xs, buffer, state, code) {
  state.x += 1;
  buffer.text += code[0];
  state.name = 'string';
  return [xs, buffer, state, code.slice(1)];
};

_string_backslash = function(xs, buffer, state, code) {
  state.name = 'escape';
  state.x += 1;
  return [xs, buffer, state, code.slice(1)];
};

_string_newline = function(xs, buffer, state, code) {
  throw new Error('newline in a string');
};

_string_quote = function(xs, buffer, state, code) {
  state.name = 'token';
  state.x += 1;
  return [xs, buffer, state, code.slice(1)];
};

_string_else = function(xs, buffer, state, code) {
  state.x += 1;
  buffer.text += code[0];
  return [xs, buffer, state, code.slice(1)];
};

_space_space = function(xs, buffer, state, code) {
  state.x += 1;
  return [xs, buffer, state, code.slice(1)];
};

_space_newline = function(xs, buffer, state, code) {
  if (state.nest !== 0) {
    throw Error('incorrect nesting');
  }
  state.name = 'indent';
  state.x = 1;
  state.y += 1;
  state.indented = 0;
  return [xs, buffer, state, code.slice(1)];
};

_space_open = function(xs, buffer, state, code) {
  var nesting;
  nesting = tree.createNesting(1);
  xs = tree.appendItem(xs, state.level, nesting);
  state.nest += 1;
  state.level += 1;
  state.x += 1;
  return [xs, buffer, state, code.slice(1)];
};

_space_close = function(xs, buffer, state, code) {
  state.nest -= 1;
  state.level -= 1;
  if (state.nest < 0) {
    throw new Error('close at space');
  }
  state.x += 1;
  return [xs, buffer, state, code.slice(1)];
};

_space_quote = function(xs, buffer, state, code) {
  state.name = 'string';
  buffer = {
    text: '',
    x: state.x,
    y: state.y,
    path: state.path
  };
  state.x += 1;
  return [xs, buffer, state, code.slice(1)];
};

_space_else = function(xs, buffer, state, code) {
  state.name = 'token';
  buffer = {
    text: code[0],
    x: state.x,
    y: state.y,
    path: state.path
  };
  state.x += 1;
  return [xs, buffer, state, code.slice(1)];
};

_token_space = function(xs, buffer, state, code) {
  state.name = 'space';
  buffer.ex = state.x;
  buffer.ey = state.y;
  xs = tree.appendItem(xs, state.level, buffer);
  state.x += 1;
  buffer = null;
  return [xs, buffer, state, code.slice(1)];
};

_token_newline = function(xs, buffer, state, code) {
  state.name = 'indent';
  buffer.ex = state.x;
  buffer.ey = state.y;
  xs = tree.appendItem(xs, state.level, buffer);
  state.indented = 0;
  state.x = 1;
  state.y += 1;
  buffer = null;
  return [xs, buffer, state, code.slice(1)];
};

_token_open = function(xs, buffer, state, code) {
  throw new Error('open parenthesis in token');
};

_token_close = function(xs, buffer, state, code) {
  state.name = 'space';
  buffer.ex = state.x;
  buffer.ey = state.y;
  xs = tree.appendItem(xs, state.level, buffer);
  buffer = null;
  return [xs, buffer, state, code];
};

_token_quote = function(xs, buffer, state, code) {
  state.name = 'string';
  state.x += 1;
  return [xs, buffer, state, code.slice(1)];
};

_token_else = function(xs, buffer, state, code) {
  buffer.text += code[0];
  state.x += 1;
  return [xs, buffer, state, code.slice(1)];
};

_indent_space = function(xs, buffer, state, code) {
  state.indented += 1;
  state.x += 1;
  return [xs, buffer, state, code.slice(1)];
};

_indent_newilne = function(xs, buffer, state, code) {
  state.x = 1;
  state.y += 1;
  state.indented = 0;
  return [xs, buffer, state, code.slice(1)];
};

_indent_close = function(xs, buffer, state, code) {
  throw new Error('close parenthesis at indent');
};

_indent_else = function(xs, buffer, state, code) {
  var diff, indented, nesting;
  state.name = 'space';
  if ((state.indented % 2) === 1) {
    throw new Error('odd indentation');
  }
  indented = state.indented / 2;
  diff = indented - state.indent;
  if (diff <= 0) {
    nesting = tree.createNesting(1);
    xs = tree.appendItem(xs, state.level + diff - 1, nesting);
  } else if (diff > 0) {
    nesting = tree.createNesting(diff);
    xs = tree.appendItem(xs, state.level, nesting);
  }
  state.level += diff;
  state.indent = indented;
  return [xs, buffer, state, code];
};

parse = function(xs, buffer, state, code) {
  var args, char, eof;
  args = [xs, buffer, state, code];
  eof = code.length === 0;
  char = code[0];
  switch (state.name) {
    case 'escape':
      if (eof) {
        return _escape_eof.apply(null, args);
      } else {
        switch (char) {
          case '\n':
            return _escape_newline.apply(null, args);
          case 'n':
            return _escape_n.apply(null, args);
          case 't':
            return _escape_t.apply(null, args);
          default:
            return _escape_else.apply(null, args);
        }
      }
      break;
    case 'string':
      if (eof) {
        return _string_eof.apply(null, args);
      } else {
        switch (char) {
          case '\\':
            return _string_backslash.apply(null, args);
          case '\n':
            return _string_newline.apply(null, args);
          case '"':
            return _string_quote.apply(null, args);
          default:
            return _string_else.apply(null, args);
        }
      }
      break;
    case 'space':
      if (eof) {
        return _space_eof.apply(null, args);
      } else {
        switch (char) {
          case ' ':
            return _space_space.apply(null, args);
          case '\n':
            return _space_newline.apply(null, args);
          case '(':
            return _space_open.apply(null, args);
          case ')':
            return _space_close.apply(null, args);
          case '"':
            return _space_quote.apply(null, args);
          default:
            return _space_else.apply(null, args);
        }
      }
      break;
    case 'token':
      if (eof) {
        return _token_eof.apply(null, args);
      } else {
        switch (char) {
          case ' ':
            return _token_space.apply(null, args);
          case '\n':
            return _token_newline.apply(null, args);
          case '(':
            return _token_open.apply(null, args);
          case ')':
            return _token_close.apply(null, args);
          case '"':
            return _token_quote.apply(null, args);
          default:
            return _token_else.apply(null, args);
        }
      }
      break;
    case 'indent':
      if (eof) {
        return _indent_eof.apply(null, args);
      } else {
        switch (char) {
          case ' ':
            return _indent_space.apply(null, args);
          case '\n':
            return _indent_newilne.apply(null, args);
          case ')':
            return _indent_close.apply(null, args);
          default:
            return _indent_else.apply(null, args);
        }
      }
  }
};
